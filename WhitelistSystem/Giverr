-- Advanced Whitelist System with GitHub Integration
local WhitelistSystem = {}

-- Configuration
WhitelistSystem.Config = {
    LocalFile = "Whitelist_System.lua",
    GitHubRawURL = "https://raw.githubusercontent.com/TryharderKid/Ff/main/WWhitelist_Data.lua",
    Debug = true  -- Enable debug mode to help troubleshoot
}

-- Debug print function
local function debugPrint(...)
    if WhitelistSystem.Config.Debug then
        print("[Whitelist Debug]", ...)
    end
end

-- Generate a whitelist string for the current user
function WhitelistSystem:GenerateWhitelistString()
    -- Safe function caller
    local function safecall(func, ...)
        if type(func) == "function" then
            local success, result = pcall(func, ...)
            if success then return result end
        end
        return nil
    end
    
    -- Get HWID with multiple fallbacks
    local hwid = nil
    hwid = safecall(function() return getexecutorhwid() end)
    if not hwid then hwid = safecall(function() return gethwid() end) end
    if not hwid then hwid = safecall(function() return get_hwid() end) end
    if not hwid then hwid = safecall(function() return getexecutoridentifier() end) end
    if not hwid then hwid = "UNKNOWN_HWID" end
    
    -- Get user data
    local userId = game:GetService("Players").LocalPlayer.UserId
    
    -- Get client ID
    local clientID = "UNKNOWN_CLIENT_ID"
    pcall(function()
        clientID = game:GetService("RbxAnalyticsService"):GetClientId()
    end)
    
    -- Create a persistent ID
    local function getPersistentID()
        local HttpService = game:GetService("HttpService")
        local filename = "lurnai_persistent_id.dat"
        
        local existingID = nil
        pcall(function()
            if readfile then existingID = readfile(filename) end
        end)
        
        if existingID and #existingID > 10 then
            return existingID
        end
        
        local newID = HttpService:GenerateGUID(false)
        pcall(function()
            if writefile then writefile(filename, newID) end
        end)
        
        return newID
    end
    
    local persistentID = getPersistentID()
    
    -- Get player name
    local playerName = game:GetService("Players").LocalPlayer.Name
    
    -- Get executor name
    local executorName = "Unknown"
    pcall(function()
        if identifyexecutor then executorName = identifyexecutor() end
        if executorName == "Unknown" and getexecutorname then executorName = getexecutorname() end
    end)
    
    -- Format the whitelist string with all identifiers
    local whitelistString = string.format("Lurnai_%s_%s_%s_%s_%s_%s", 
        hwid,
        tostring(userId),
        tostring(persistentID),
        tostring(clientID),
        playerName,
        executorName
    )
    
    return whitelistString
end

-- Obfuscate the whitelist string
function WhitelistSystem:ObfuscateWhitelistString(whitelistString)
    -- Create a secure hash
    local function secureHash(str)
        local h = 0x21F4A3B7
        for i = 1, #str do
            local byte = string.byte(str, i)
            h = ((h * 31) + byte) % 0x7FFFFFFF
            local h_shifted = math.floor(h / 8192)
            h = ((h - (h_shifted * 8192)) * 0x85EBCA77) % 0x7FFFFFFF
            h_shifted = math.floor(h / 65536)
            h = ((h - (h_shifted * 65536)) * 0xC2B2AE3D) % 0x7FFFFFFF
            h_shifted = math.floor(h / 65536)
            h = (h - (h_shifted * 65536)) % 0x7FFFFFFF
        end
        return h
    end
    
    -- Create a unique key from the hash and timestamp
    local timestamp = os.time()
    local hash = secureHash(whitelistString .. tostring(timestamp))
    
    -- Create a character set
    local charSet = {
        -- Set 1 (20 chars)
        "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
        "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
        
        -- Set 2 (20 chars)
        "a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
        "k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
        
        -- Set 3 (20 chars)
        "U", "V", "W", "X", "Y", "Z", "0", "1", "2", "3",
        "4", "5", "6", "7", "8", "9", "!", "@", "#", "$",
        
        -- Set 4 (20 chars)
        "u", "v", "w", "x", "y", "z", "%", "^", "&", "*",
        "(", ")", "-", "+", "=", "[", "]", "{", "}", ";"
    }
    
    -- Create a custom encoding function
    local function customEncode(str, key)
        local result = ""
        local keyValue = key
        
        -- Add a marker prefix
        result = "##SECURE##"
        
        -- Encode the timestamp
        local timeChars = {}
        local timeStr = tostring(timestamp)
        for i = 1, #timeStr do
            local digit = tonumber(string.sub(timeStr, i, i))
            timeChars[i] = charSet[digit + 1]
        end
        
        -- Add timestamp markers
        result = result .. "<<TIME>>"
        for i = 1, #timeChars do
            result = result .. timeChars[i]
        end
        result = result .. "<</TIME>>"
        
        -- Now encode the actual string
        for i = 1, #str do
            local char = string.sub(str, i, i)
            local byte = string.byte(char)
            
            -- Create a complex transformation based on position, key, and byte value
            keyValue = (keyValue * 75) % 79
            local transformedValue = (byte * 13 + keyValue * 29 + i * 7) % 80
            
            -- Split into four indices to use different character sets
            local index1 = (transformedValue % 20) + 1
            local index2 = ((transformedValue + 17) % 20) + 21
            local index3 = ((transformedValue + 37) % 20) + 41
            local index4 = ((transformedValue + 59) % 20) + 61
            
            -- Get characters from different sections of our character set
            local char1 = charSet[index1]
            local char2 = charSet[index2]
            local char3 = charSet[index3]
            local char4 = charSet[index4]
            
            -- Add a position-based separator
            local separator = (i % 5 == 0) and "." or
                              (i % 5 == 1) and "_" or
                             (i % 5 == 2) and "-" or
                             (i % 5 == 3) and "+" or ":"
            
            -- Add the encoded group
            result = result .. char1 .. char2 .. char3 .. char4 .. separator
        end
        
        -- Add a verification signature
        local verificationHash = secureHash(str .. tostring(key) .. tostring(timestamp))
        local verificationChars = {}
        local verStr = tostring(verificationHash)
        for i = 1, math.min(5, #verStr) do
            local digit = tonumber(string.sub(verStr, i, i))
            verificationChars[i] = charSet[digit + 1]
        end
        
        result = result .. "<<VERIFY>>"
        for i = 1, #verificationChars do
            result = result .. verificationChars[i]
        end
        result = result .. "<</VERIFY>>"
        
        return result
    end
    
    return customEncode(whitelistString, hash)
end

-- Create or update the local whitelist file
function WhitelistSystem:CreateLocalWhitelistFile()
    local originalWhitelist = self:GenerateWhitelistString()
    local obfuscatedWhitelist = self:ObfuscateWhitelistString(originalWhitelist)
    
    debugPrint("Generated original whitelist: " .. originalWhitelist)
    debugPrint("Generated obfuscated whitelist: " .. obfuscatedWhitelist)
    
    local success, result = pcall(function()
        if writefile then
            local content = [[
-- Whitelist System
-- This file contains your whitelist information
-- DO NOT MODIFY THIS FILE
local WhitelistData = {
    -- Original unobfuscated whitelist string
    Original = "]] .. originalWhitelist .. [[",
    
    -- Obfuscated whitelist string
    Obfuscated = "]] .. obfuscatedWhitelist .. [["
}
return WhitelistData]]
            
            writefile(self.Config.LocalFile, content)
            return true
        else
            error("Cannot write local files")
        end
    end)
    
    if success then
        debugPrint("Successfully created local whitelist file")
        return {
            original = originalWhitelist,
            obfuscated = obfuscatedWhitelist
        }
    else
        debugPrint("Failed to create local whitelist file:", result)
        return {
            original = originalWhitelist,
            obfuscated = obfuscatedWhitelist
        }
    end
end

-- Load the local whitelist file
function WhitelistSystem:LoadLocalWhitelistFile()
    local success, result = pcall(function()
        if readfile and isfile and isfile(self.Config.LocalFile) then
            local content = readfile(self.Config.LocalFile)
            local func, err = loadstring(content)
            if func then
                local whitelistData = func()
                if type(whitelistData) == "table" and whitelistData.Original and whitelistData.Obfuscated then
                    return whitelistData
                else
                    error("Invalid whitelist data format")
                end
            else
                error("Failed to parse whitelist data: " .. tostring(err))
            end
        else
            error("Whitelist file does not exist")
        end
    end)
    
    if success then
        debugPrint("Successfully loaded local whitelist file")
        return {
            original = result.Original,
            obfuscated = result.Obfuscated
        }
    else
        debugPrint("Failed to load local whitelist file:", result)
        return nil
    end
end

-- Fetch whitelist data from GitHub
function WhitelistSystem:FetchWhitelistData()
    debugPrint("Fetching whitelist data from: " .. self.Config.GitHubRawURL)
    
    local success, result = pcall(function()
        local response = game:HttpGet(self.Config.GitHubRawURL)
        
        debugPrint("Received response from GitHub")
        
        -- Basic validation to ensure it's a Lua table
        if response:match("return%s*{") then
            -- Use loadstring to convert the response to a Lua table
            local func, err = loadstring(response)
            if func then
                local whitelistData = func()
                if type(whitelistData) == "table" then
                    debugPrint("Successfully parsed whitelist data, entries: " .. #whitelistData)
                    return whitelistData
                else
                    error("Whitelist data is not a table")
                end
            else
                error("Failed to parse whitelist data: " .. tostring(err))
            end
        else
            error("Invalid whitelist data format")
        end
    end)
    
    if success then
        debugPrint("Successfully fetched whitelist data from GitHub")
        return result
    else
        debugPrint("Failed to fetch whitelist data from GitHub:", result)
        return nil
    end
end

-- Debug function to help troubleshoot whitelist issues
function WhitelistSystem:DebugWhitelistCheck()
    -- Get local whitelist
    local localWhitelist = self:LoadLocalWhitelistFile() or self:CreateLocalWhitelistFile()
    
    debugPrint("Local whitelist loaded/created")
    debugPrint("Original: " .. string.sub(localWhitelist.original, 1, 30) .. "...")
    debugPrint("Obfuscated: " .. string.sub(localWhitelist.obfuscated, 1, 30) .. "...")
    
    -- Fetch GitHub whitelist
    local githubWhitelist = self:FetchWhitelistData()
    
    if not githubWhitelist then
        debugPrint("ERROR: Could not fetch whitelist data from GitHub")
        return false
    end
    
    debugPrint("GitHub whitelist fetched, entries: " .. #githubWhitelist)
    
    -- Check each whitelist entry
    for i, entry in ipairs(githubWhitelist) do
        -- Trim any whitespace that might cause issues
        entry = entry:gsub("^%s*(.-)%s*$", "%1")
        
        debugPrint("Checking whitelist entry #" .. i)
        debugPrint("GitHub entry starts with: " .. string.sub(entry, 1, 30) .. "...")
        
        if entry == localWhitelist.original then
            debugPrint("MATCH FOUND with original string!")
            return true
        elseif entry == localWhitelist.obfuscated then
            debugPrint("MATCH FOUND with obfuscated string!")
            return true
        end
    end
    
    debugPrint("No match found in whitelist database")
    return false
end

-- Check if the user is whitelisted
function WhitelistSystem:CheckWhitelist()
    -- First, try to load the local whitelist file
    local localWhitelist = self:LoadLocalWhitelistFile()
    
    -- If the local whitelist file doesn't exist or is invalid, create it
    if not localWhitelist then
        debugPrint("Creating new local whitelist file...")
        localWhitelist = self:CreateLocalWhitelistFile()
        
        -- Copy the obfuscated whitelist to clipboard
        pcall(function()
            if setclipboard then
                setclipboard(localWhitelist.obfuscated)
                print("Your obfuscated whitelist string has been copied to clipboard.")
            elseif writeclipboard then
                writeclipboard(localWhitelist.obfuscated)
                print("Your obfuscated whitelist string has been copied to clipboard.")
            else
                print("Your obfuscated whitelist string: " .. localWhitelist.obfuscated)
            end
            print("Contact the developer with this string to get whitelisted.")
        end)
    end
    
    -- Try to fetch whitelist data from GitHub
    local githubWhitelist = self:FetchWhitelistData()
    
    -- If we couldn't fetch the whitelist data, return false
    if not githubWhitelist then
        print("❌ Could not fetch whitelist data from GitHub")
        return false
    end
    
    debugPrint("Successfully fetched whitelist data, entries: " .. #githubWhitelist)
    debugPrint("Checking if user is whitelisted...")
    
    -- Check if the user's whitelist string is in the whitelist
    for i, entry in ipairs(githubWhitelist) do
        -- Trim any whitespace that might cause issues
        entry = entry:gsub("^%s*(.-)%s*$", "%1")
        
        debugPrint("Checking entry #" .. i .. ": " .. string.sub(entry, 1, 30) .. "...")
        
        -- Compare with both original and obfuscated strings
        if entry == localWhitelist.original then
            debugPrint("Match found with original string!")
            return true
        elseif entry == localWhitelist.obfuscated then
            debugPrint("Match found with obfuscated string!")
            return true
        end
        
        -- Additional check: compare without any potential whitespace or invisible characters
        local cleanEntry = entry:gsub("%s", "")
        local cleanOriginal = localWhitelist.original:gsub("%s", "")
        local cleanObfuscated = localWhitelist.obfuscated:gsub("%s", "")
        
        if cleanEntry == cleanOriginal or cleanEntry == cleanObfuscated then
            debugPrint("Match found after cleaning whitespace!")
            return true
        end
    end
    
    -- If not whitelisted, copy the obfuscated whitelist to clipboard again
    print("❌ Not whitelisted. Copying whitelist string to clipboard...")
    
    pcall(function()
        if setclipboard then
            setclipboard(localWhitelist.obfuscated)
            print("📋 Your obfuscated whitelist string has been copied to clipboard.")
        elseif writeclipboard then
            writeclipboard(localWhitelist.obfuscated)
            print("📋 Your obfuscated whitelist string has been copied to clipboard.")
        else
            print("📋 Your obfuscated whitelist string: " .. localWhitelist.obfuscated)
        end
        print("⚠️ Contact the developer with this string to get whitelisted.")
    end)
    
    return false
end

-- Initialize the whitelist system
function WhitelistSystem:Initialize()
    print("🔒 Initializing whitelist system...")
    
    -- Run the debug check first to help troubleshoot
    if self.Config.Debug then
        print("🔍 Running debug check...")
        self:DebugWhitelistCheck()
    end
    
    -- Check if the user is whitelisted
    local isWhitelisted = self:CheckWhitelist()
    
    if isWhitelisted then
        print("✅ Access granted! You are whitelisted.")
        
        -- Show a success notification in-game
        pcall(function()
            local StarterGui = game:GetService("StarterGui")
            StarterGui:SetCore("SendNotification", {
                Title = "Whitelist Check Passed",
                Text = "You are whitelisted. Enjoy!",
                Duration = 5
            })
        end)
        
        return true
    else
        print("❌ Access denied! You are not whitelisted.")
        
        -- Show a notification in-game
        pcall(function()
            local StarterGui = game:GetService("StarterGui")
            StarterGui:SetCore("SendNotification", {
                Title = "Whitelist Check Failed",
                Text = "You are not whitelisted. Contact the developer.",
                Duration = 10
            })
        end)
        
        return false
    end
end

-- Add a function to manually add a user to the whitelist file (for testing)
function WhitelistSystem:AddToLocalWhitelist(whitelistString)
    local success, result = pcall(function()
        if readfile and writefile and isfile and isfile(self.Config.LocalFile) then
            local content = readfile(self.Config.LocalFile)
            local func, err = loadstring(content)
            if func then
                local whitelistData = func()
                if type(whitelistData) == "table" then
                    -- Add the new whitelist string
                    table.insert(whitelistData, whitelistString)
                    
                    -- Write the updated whitelist back to the file
                    local newContent = "return " .. game:GetService("HttpService"):JSONEncode(whitelistData)
                    writefile(self.Config.LocalFile, newContent)
                    
                    return true
                else
                    error("Invalid whitelist data format")
                end
            else
                error("Failed to parse whitelist data: " .. tostring(err))
            end
        else
            error("Whitelist file does not exist")
        end
    end)
    
    return success
end

-- Return the whitelist system
return WhitelistSystem
