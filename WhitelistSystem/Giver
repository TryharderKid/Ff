-- Ultra-Secure Whitelist System with No Exposed Numbers
local SecureWhitelist = {
    GenerateWhitelistString = function(self)
        -- Safe function caller
        local function safecall(func, ...)
            if type(func) == "function" then
                local success, result = pcall(func, ...)
                if success then return result end
            end
            return nil
        end
        
        -- Get HWID with multiple fallbacks
        local hwid = nil
        hwid = safecall(function() return getexecutorhwid() end)
        if not hwid then hwid = safecall(function() return gethwid() end) end
        if not hwid then hwid = safecall(function() return get_hwid() end) end
        if not hwid then hwid = safecall(function() return getexecutoridentifier() end) end
        if not hwid then hwid = "UNKNOWN_HWID" end
        
        -- Get user data
        local userId = game:GetService("Players").LocalPlayer.UserId
        
        -- Get client ID
        local clientID = "UNKNOWN_CLIENT_ID"
        pcall(function()
            clientID = game:GetService("RbxAnalyticsService"):GetClientId()
        end)
        
        -- Create a persistent ID
        local function getPersistentID()
            local HttpService = game:GetService("HttpService")
            local filename = "lurnai_persistent_id.dat"
            
            local existingID = nil
            pcall(function()
                if readfile then existingID = readfile(filename) end
            end)
            
            if existingID and #existingID > 10 then
                return existingID
            end
            
            local newID = HttpService:GenerateGUID(false)
            pcall(function()
                if writefile then writefile(filename, newID) end
            end)
            
            return newID
        end
        
        local persistentID = getPersistentID()
        
        -- Get player name
        local playerName = game:GetService("Players").LocalPlayer.Name
        
        -- Get executor name
        local executorName = "Unknown"
        pcall(function()
            if identifyexecutor then executorName = identifyexecutor() end
            if executorName == "Unknown" and getexecutorname then executorName = getexecutorname() end
        end)
        
        -- Format the whitelist string with all identifiers
        local whitelistString = string.format("%s_%s_%s_%s_%s_%s", 
            hwid,
            tostring(userId),
            tostring(persistentID),
            tostring(clientID),
            playerName,
            executorName
        )
        
        -- Create a completely custom encoding system
        
        -- First, create a secure hash
        local function secureHash(str)
            local h = 0x21F4A3B7
            for i = 1, #str do
                local byte = string.byte(str, i)
                h = ((h * 31) + byte) % 0x7FFFFFFF
                -- Use bit operations that are compatible with Lua 5.1
                local h_shifted = math.floor(h / 8192) -- equivalent to h >> 13
                h = ((h - (h_shifted * 8192)) * 0x85EBCA77) % 0x7FFFFFFF
                h_shifted = math.floor(h / 65536) -- equivalent to h >> 16
                h = ((h - (h_shifted * 65536)) * 0xC2B2AE3D) % 0x7FFFFFFF
                h_shifted = math.floor(h / 65536) -- equivalent to h >> 16
                h = (h - (h_shifted * 65536)) % 0x7FFFFFFF
            end
            return h
        end
        
        -- Create a unique key from the hash and timestamp
        local timestamp = os.time()
        local hash = secureHash(whitelistString .. tostring(timestamp))
        
        -- Create a completely custom character set with no numbers
        local charSet = {
            -- Mythical creatures (20 chars)
            "ğŸ‰", "ğŸ¦„", "ğŸ§š", "ğŸ§™", "ğŸ§œ", "ğŸ§", "ğŸ§", "ğŸ§Ÿ", "ğŸ‘¹", "ğŸ‘º", 
            "ğŸ‘»", "ğŸ‘½", "ğŸ‘¾", "ğŸ¦Š", "ğŸ¦", "ğŸ²", "ğŸ¦…", "ğŸ¦‡", "ğŸ¦‹", "ğŸ¦‚",
            
            -- Celestial symbols (20 chars)
            "â­", "ğŸŒŸ", "ğŸ’«", "âœ¨", "â˜„ï¸", "ğŸŒ ", "ğŸŒŒ", "ğŸª", "ğŸŒ‘", "ğŸŒ’", 
            "ğŸŒ“", "ğŸŒ”", "ğŸŒ•", "ğŸŒ–", "ğŸŒ—", "ğŸŒ˜", "ğŸŒ™", "â˜€ï¸", "ğŸŒ", "ğŸŒš",
            
            -- Magical symbols (20 chars)
            "âœ¨", "ğŸ’«", "âš¡", "ğŸ”®", "âš”ï¸", "ğŸ›¡ï¸", "ğŸ¹", "ğŸ—¡ï¸", "ğŸ§¿", "ğŸ“¿", 
            "ğŸ”¯", "âœ¡ï¸", "â˜¸ï¸", "â˜¯ï¸", "âœï¸", "â˜¦ï¸", "â˜ªï¸", "â˜®ï¸", "ğŸ•‰ï¸", "ğŸ”±",
            
            -- Ancient symbols (20 chars)
            "ğ“€€", "ğ“€", "ğ“€‚", "ğ“€ƒ", "ğ“€„", "ğ“€…", "ğ“€†", "ğ“€‡", "ğ“€ˆ", "ğ“€‰", 
            "ğ“€Š", "ğ“€‹", "ğ“€Œ", "ğ“€", "ğ“€", "ğ“€", "ğ“€", "ğ“€‘", "ğ“€’", "ğ“€“"
        }
        
        -- Create a completely custom encoding function
        local function customEncode(str, key)
            local result = ""
            local keyValue = key
            
            -- Add a marker prefix that looks magical
            result = "âœ§âšğŸ”®ğŸ§¿"
            
            -- Encode the timestamp in a way that doesn't expose numbers
            local timeChars = {}
            local timeStr = tostring(timestamp)
            for i = 1, #timeStr do
                local digit = tonumber(string.sub(timeStr, i, i))
                timeChars[i] = charSet[digit + 1] -- +1 because Lua is 1-indexed
            end
            
            -- Add timestamp markers
            result = result .. "ğŸ•°ï¸"
            for i = 1, #timeChars do
                result = result .. timeChars[i]
            end
            result = result .. "ğŸ•°ï¸"
            
            -- Now encode the actual string
            for i = 1, #str do
                local char = string.sub(str, i, i)
                local byte = string.byte(char)
                
                -- Create a complex transformation based on position, key, and byte value
                keyValue = (keyValue * 75) % 79 -- Prime number operations for better distribution
                local transformedValue = (byte * 13 + keyValue * 29 + i * 7) % 80
                
                -- Split into four indices to use different character sets
                local index1 = (transformedValue % 20) + 1
                local index2 = ((transformedValue + 17) % 20) + 21
                local index3 = ((transformedValue + 37) % 20) + 41
                local index4 = ((transformedValue + 59) % 20) + 61
                
                -- Get characters from different sections of our character set
                local char1 = charSet[index1]
                local char2 = charSet[index2]
                local char3 = charSet[index3]
                local char4 = charSet[index4]
                
                -- Add a position-based separator
                local separator = (i % 5 == 0) and "âœ¦" or 
                                 (i % 5 == 1) and "âœ§" or
                                 (i % 5 == 2) and "âœª" or
                                 (i % 5 == 3) and "âœ«" or "âœ¬"
                
                -- Add the encoded group
                result = result .. char1 .. char2 .. char3 .. char4 .. separator
            end
            
            -- Add a verification signature
            local verificationHash = secureHash(str .. tostring(key) .. tostring(timestamp))
            local verificationChars = {}
            local verStr = tostring(verificationHash)
            for i = 1, math.min(8, #verStr) do
                local digit = tonumber(string.sub(verStr, i, i))
                verificationChars[i] = charSet[digit + 1]
            end
            
            result = result .. "ğŸ”’"
            for i = 1, #verificationChars do
                result = result .. verificationChars[i]
            end
            result = result .. "ğŸ”’"
            
            return result
        end
        
        -- Generate the final whitelist string
        local finalString = customEncode(whitelistString, hash)
        print("Generated whitelist string:", finalString)
        return finalString
    end,
    
    VerifyAccess = function(self, whitelistData)
        -- Generate the user's whitelist string
        local userWhitelistString = self:GenerateWhitelistString()
        
        -- Check if the user's whitelist string is in the whitelist
        for _, whitelistedString in ipairs(whitelistData) do
            if whitelistedString == userWhitelistString then
                print("âœ… Access granted! You are whitelisted.")
                return true
            end
        end
        
        print("âŒ Access denied! You are not whitelisted.")
        -- Copy the user's whitelist string to clipboard for easy whitelisting
        pcall(function()
            if setclipboard then
                setclipboard(userWhitelistString)
                print("Your whitelist string has been copied to clipboard. Contact the developer to get whitelisted.")
            elseif writeclipboard then
                writeclipboard(userWhitelistString)
                print("Your whitelist string has been copied to clipboard. Contact the developer to get whitelisted.")
            else
                print("Your whitelist string: " .. userWhitelistString)
                print("Contact the developer with this string to get whitelisted.")
            end
        end)
        
        return false
    end
}

-- Empty whitelist data for testing
local whitelistData = {}

-- Generate a whitelist string for the current user
local userString = SecureWhitelist:GenerateWhitelistString()
print("Add this string to your whitelist_data.lua file:")
print(userString)

-- Verify access (will fail since whitelist is empty)
local hasAccess = SecureWhitelist:VerifyAccess(whitelistData)
if hasAccess then
    print("Whitelist verification successful! You can now load your main script.")
else
    print("Whitelist verification failed. Please add your string to the whitelist.")
end
