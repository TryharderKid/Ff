-- Advanced Whitelist System with Custom Obfuscation
local WhitelistSystem = {
    GenerateWhitelistString = function(self)
        -- Safe function caller
        local function safecall(func, ...)
            if type(func) == "function" then
                local success, result = pcall(func, ...)
                if success then return result end
            end
            return nil
        end
        
        -- Get HWID with multiple fallbacks
        local hwid = nil
        hwid = safecall(function() return getexecutorhwid() end)
        if not hwid then hwid = safecall(function() return gethwid() end) end
        if not hwid then hwid = safecall(function() return get_hwid() end) end
        if not hwid then hwid = safecall(function() return getexecutoridentifier() end) end
        if not hwid then hwid = "UNKNOWN_HWID" end
        
        -- Get user data
        local userId = game:GetService("Players").LocalPlayer.UserId
        
        -- Get client ID
        local clientID = "UNKNOWN_CLIENT_ID"
        pcall(function()
            clientID = game:GetService("RbxAnalyticsService"):GetClientId()
        end)
        
        -- Create a persistent ID
        local function getPersistentID()
            local HttpService = game:GetService("HttpService")
            local filename = "lurnai_persistent_id.dat"
            
            local existingID = nil
            pcall(function()
                if readfile then existingID = readfile(filename) end
            end)
            
            if existingID and #existingID > 10 then
                return existingID
            end
            
            local newID = HttpService:GenerateGUID(false)
            pcall(function()
                if writefile then writefile(filename, newID) end
            end)
            
            return newID
        end
        
        local persistentID = getPersistentID()
        
        -- Get player name
        local playerName = game:GetService("Players").LocalPlayer.Name
        
        -- Get executor name
        local executorName = "Unknown"
        pcall(function()
            if identifyexecutor then executorName = identifyexecutor() end
            if executorName == "Unknown" and getexecutorname then executorName = getexecutorname() end
        end)
        
        -- Print all components for debugging
        print("HWID:", hwid)
        print("UserID:", userId)
        print("ClientID:", clientID)
        print("PersistentID:", persistentID)
        print("PlayerName:", playerName)
        print("ExecutorName:", executorName)
        
        -- Format the whitelist string with all identifiers
        local whitelistString = string.format("%s_%s_%s_%s_%s_%s", 
            hwid,
            tostring(userId),
            tostring(persistentID),
            tostring(clientID),
            playerName,
            executorName
        )
        
        -- Custom advanced hashing function
        local function customHash(str)
            local h1, h2, h3, h4 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476
            
            local function F(x, y, z) return (x & y) | (~x & z) end
            local function G(x, y, z) return (x & z) | (y & ~z) end
            local function H(x, y, z) return x ~ y ~ z end
            local function I(x, y, z) return y ~ (x | ~z) end
            
            local function rotateLeft(x, n)
                return ((x << n) | (x >> (32 - n))) & 0xFFFFFFFF
            end
            
            -- Process each character
            for i = 1, #str, 4 do
                local a, b, c, d = h1, h2, h3, h4
                
                -- Get up to 4 bytes
                local bytes = {0, 0, 0, 0}
                for j = 0, 3 do
                    if i + j <= #str then
                        bytes[j+1] = string.byte(str, i + j)
                    end
                end
                
                -- Mix operations
                a = (a + F(b, c, d) + bytes[1]) & 0xFFFFFFFF
                a = rotateLeft(a, 7)
                a = (a + b) & 0xFFFFFFFF
                
                d = (d + G(a, b, c) + bytes[2]) & 0xFFFFFFFF
                d = rotateLeft(d, 12)
                d = (d + a) & 0xFFFFFFFF
                
                c = (c + H(d, a, b) + bytes[3]) & 0xFFFFFFFF
                c = rotateLeft(c, 17)
                c = (c + d) & 0xFFFFFFFF
                
                b = (b + I(c, d, a) + bytes[4]) & 0xFFFFFFFF
                b = rotateLeft(b, 22)
                b = (b + c) & 0xFFFFFFFF
                
                h1, h2, h3, h4 = (h1 + a) & 0xFFFFFFFF, (h2 + b) & 0xFFFFFFFF, (h3 + c) & 0xFFFFFFFF, (h4 + d) & 0xFFFFFFFF
            end
            
            return string.format("%08x%08x%08x%08x", h1, h2, h3, h4)
        end
        
        -- Custom character sets for obfuscation
        local symbolSet1 = {"⚡", "✨", "⭐", "🔥", "💫", "⚔️", "🛡️", "🏹", "🗡️", "🔮"}
        local symbolSet2 = {"🌑", "🌒", "🌓", "🌔", "🌕", "🌖", "🌗", "🌘", "🌙", "🌚"}
        local chineseSet = {"龍", "鳳", "虎", "麒", "鷹", "狼", "鹿", "熊", "蛇", "鯨"}
        local runicSet = {"ᚠ", "ᚢ", "ᚦ", "ᚨ", "ᚱ", "ᚲ", "ᚷ", "ᚹ", "ᚺ", "ᚾ"}
        
        -- Advanced custom obfuscation
        local function customObfuscate(str)
            local hash = customHash(str)
            local timestamp = os.time()
            local seed = timestamp % 1000
            
            -- Create a unique key based on timestamp and hash
            local key = ""
            for i = 1, 8 do
                local hashPart = tonumber(string.sub(hash, (i-1)*4 + 1, i*4), 16) or 0
                key = key .. string.char((hashPart % 26) + 65)
            end
            
            -- Initialize result with a marker and timestamp
            local result = "✧⚝" .. string.char(seed % 26 + 65) .. string.char((seed + 7) % 26 + 65)
            
            -- Add the hash in an obfuscated form
            for i = 1, #hash, 2 do
                local hashPart = string.sub(hash, i, i+1)
                local value = tonumber(hashPart, 16) or 0
                
                -- Select character set based on position
                local charSet = (i % 8 == 0) and symbolSet1 or
                               (i % 8 == 2) and symbolSet2 or
                               (i % 8 == 4) and chineseSet or runicSet
                
                -- Map value to character
                local index = (value % #charSet) + 1
                result = result .. charSet[index]
            end
            
            -- Add separator
            result = result .. "⚜️"
            
            -- Encode the actual string with multiple layers
            for i = 1, #str do
                local char = string.sub(str, i, i)
                local byte = string.byte(char)
                
                -- Apply key-based transformation
                local keyChar = string.sub(key, (i % #key) + 1, (i % #key) + 1)
                local keyByte = string.byte(keyChar)
                
                -- Complex transformation
                local transformed = (byte * 3 + keyByte * 5 + seed + i) % 1000
                
                -- Split into three parts for more obfuscation
                local part1 = transformed % 10
                local part2 = math.floor(transformed / 10) % 10
                local part3 = math.floor(transformed / 100)
                
                -- Map each part to a different character set
                local symbol1 = symbolSet1[(part1 + 1)]
                local symbol2 = chineseSet[(part2 + 1)]
                local symbol3 = runicSet[(part3 + 1)]
                
                -- Add to result with position-based separator
                local separator = (i % 4 == 0) and "✦" or 
                                 (i % 4 == 1) and "✧" or
                                 (i % 4 == 2) and "✪" or "✫"
                
                result = result .. symbol1 .. symbol2 .. symbol3 .. separator
            end
            
            -- Add verification code
            local verificationCode = customHash(str .. key .. tostring(timestamp))
            result = result .. "⚝✧" .. string.sub(verificationCode, 1, 8)
            
            return result
        end
        
        local obfuscatedString = customObfuscate(whitelistString)
        print("Generated whitelist string:", obfuscatedString)
        return obfuscatedString
    end,
    
    VerifyAccess = function(self, whitelistData)
        -- Generate the user's whitelist string
        local userWhitelistString = self:GenerateWhitelistString()
        
        -- Check if the user's whitelist string is in the whitelist
        for _, whitelistedString in ipairs(whitelistData) do
            if whitelistedString == userWhitelistString then
                print("✅ 访问已授权！您已通过验证。")
                return true
            end
        end
        
        print("❌ 访问被拒绝！您未获得授权。")
        -- Copy the user's whitelist string to clipboard for easy whitelisting
        pcall(function()
            if setclipboard then
                setclipboard(userWhitelistString)
                print("您的授权码已复制到剪贴板。请联系开发者获取授权。")
            elseif writeclipboard then
                writeclipboard(userWhitelistString)
                print("您的授权码已复制到剪贴板。请联系开发者获取授权。")
            else
                print("您的授权码: " .. userWhitelistString)
                print("请使用此代码联系开发者获取授权。")
            end
        end)
        
        return false
    end,
    
    -- Admin tools for whitelist management
    AdminTools = {
        -- This function would be used by admins to decode a whitelist string
        -- It's intentionally complex and incomplete to prevent reverse engineering
        DecodePartial = function(obfuscatedString)
            if not string.match(obfuscatedString, "^✧⚝") then
                return "Invalid format"
            end
            
            -- Extract the seed characters
            local seedChar1 = string.sub(obfuscatedString, 3, 3)
            local seedChar2 = string.sub(obfuscatedString, 4, 4)
            
            -- Calculate approximate seed
            local seed = (string.byte(seedChar1) - 65) % 26
            
            -- Find the verification marker
            local verificationPos = string.find(obfuscatedString, "⚝✧")
            if not verificationPos then
                return "Corrupted string"
            end
            
            -- Extract verification code
            local verificationCode = string.sub(obfuscatedString, verificationPos + 2)
            
            return {
                seed = seed,
                verificationCode = verificationCode,
                isValid = #verificationCode == 8
            }
        end
    }
}

-- Empty whitelist data for testing
local whitelistData = {}

-- Generate a whitelist string for the current user
local userString = WhitelistSystem:GenerateWhitelistString()
print("将此授权码添加到您的whitelist_data.lua文件中:")
print(userString)

-- Verify access (will fail since whitelist is empty)
local hasAccess = WhitelistSystem:VerifyAccess(whitelistData)
if hasAccess then
    print("✅ 验证成功！您现在可以加载主脚本。")
else
    print("❌ 验证失败。请将您的授权码添加到白名单中。")
end
