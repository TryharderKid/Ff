-- Advanced Whitelist System with GitHub Integration
local WhitelistSystem = {}

-- Configuration
WhitelistSystem.Config = {
    LocalFile = "Whitelist_System.lua",
    GitHubRawURL = "https://raw.githubusercontent.com/TryharderKid/Ff/main/Whitelist_Data.lua",
    Debug = false
}

-- Debug print function
local function debugPrint(...)
    if WhitelistSystem.Config.Debug then
        print("[Whitelist Debug]", ...)
    end
end

-- Generate a whitelist string for the current user
function WhitelistSystem:GenerateWhitelistString()
    -- Safe function caller
    local function safecall(func, ...)
        if type(func) == "function" then
            local success, result = pcall(func, ...)
            if success then return result end
        end
        return nil
    end
    
    -- Get HWID with multiple fallbacks
    local hwid = nil
    hwid = safecall(function() return getexecutorhwid() end)
    if not hwid then hwid = safecall(function() return gethwid() end) end
    if not hwid then hwid = safecall(function() return get_hwid() end) end
    if not hwid then hwid = safecall(function() return getexecutoridentifier() end) end
    if not hwid then hwid = "UNKNOWN_HWID" end
    
    -- Get user data
    local userId = game:GetService("Players").LocalPlayer.UserId
    
    -- Get client ID
    local clientID = "UNKNOWN_CLIENT_ID"
    pcall(function()
        clientID = game:GetService("RbxAnalyticsService"):GetClientId()
    end)
    
    -- Create a persistent ID
    local function getPersistentID()
        local HttpService = game:GetService("HttpService")
        local filename = "lurnai_persistent_id.dat"
        
        local existingID = nil
        pcall(function()
            if readfile then existingID = readfile(filename) end
        end)
        
        if existingID and #existingID > 10 then
            return existingID
        end
        
        local newID = HttpService:GenerateGUID(false)
        pcall(function()
            if writefile then writefile(filename, newID) end
        end)
        
        return newID
    end
    
    local persistentID = getPersistentID()
    
    -- Get player name
    local playerName = game:GetService("Players").LocalPlayer.Name
    
    -- Get executor name
    local executorName = "Unknown"
    pcall(function()
        if identifyexecutor then executorName = identifyexecutor() end
        if executorName == "Unknown" and getexecutorname then executorName = getexecutorname() end
    end)
    
    -- Format the whitelist string with all identifiers
    local whitelistString = string.format("Lurnai_%s_%s_%s_%s_%s_%s", 
        hwid,
        tostring(userId),
        tostring(persistentID),
        tostring(clientID),
        playerName,
        executorName
    )
    
    return whitelistString
end

-- Obfuscate the whitelist string
function WhitelistSystem:ObfuscateWhitelistString(whitelistString)
    -- Create a secure hash
    local function secureHash(str)
        local h = 0x21F4A3B7
        for i = 1, #str do
            local byte = string.byte(str, i)
            h = ((h * 31) + byte) % 0x7FFFFFFF
            local h_shifted = math.floor(h / 8192)
            h = ((h - (h_shifted * 8192)) * 0x85EBCA77) % 0x7FFFFFFF
            h_shifted = math.floor(h / 65536)
            h = ((h - (h_shifted * 65536)) * 0xC2B2AE3D) % 0x7FFFFFFF
            h_shifted = math.floor(h / 65536)
            h = (h - (h_shifted * 65536)) % 0x7FFFFFFF
        end
        return h
    end
    
    -- Create a unique key from the hash and timestamp
    local timestamp = os.time()
    local hash = secureHash(whitelistString .. tostring(timestamp))
    
    -- Create a character set
    local charSet = {
        -- Set 1 (20 chars)
        "A", "B", "C", "D", "E", "F", "G", "H", "I", "J",
        "K", "L", "M", "N", "O", "P", "Q", "R", "S", "T",
        
        -- Set 2 (20 chars)
        "a", "b", "c", "d", "e", "f", "g", "h", "i", "j",
        "k", "l", "m", "n", "o", "p", "q", "r", "s", "t",
        
        -- Set 3 (20 chars)
        "U", "V", "W", "X", "Y", "Z", "0", "1", "2", "3",
        "4", "5", "6", "7", "8", "9", "!", "@", "#", "$",
        
        -- Set 4 (20 chars)
        "u", "v", "w", "x", "y", "z", "%", "^", "&", "*",
        "(", ")", "-", "+", "=", "[", "]", "{", "}", ";"
    }
    
    -- Create a custom encoding function
    local function customEncode(str, key)
        local result = ""
        local keyValue = key
        
        -- Add a marker prefix
        result = "##SECURE##"
        
        -- Encode the timestamp
        local timeChars = {}
        local timeStr = tostring(timestamp)
        for i = 1, #timeStr do
            local digit = tonumber(string.sub(timeStr, i, i))
            timeChars[i] = charSet[digit + 1]
        end
        
        -- Add timestamp markers
        result = result .. "<<TIME>>"
        for i = 1, #timeChars do
            result = result .. timeChars[i]
        end
        result = result .. "<</TIME>>"
        
        -- Now encode the actual string
        for i = 1, #str do
            local char = string.sub(str, i, i)
            local byte = string.byte(char)
            
            -- Create a complex transformation based on position, key, and byte value
            keyValue = (keyValue * 75) % 79
            local transformedValue = (byte * 13 + keyValue * 29 + i * 7) % 80
            
            -- Split into four indices to use different character sets
            local index1 = (transformedValue % 20) + 1
            local index2 = ((transformedValue + 17) % 20) + 21
            local index3 = ((transformedValue + 37) % 20) + 41
            local index4 = ((transformedValue + 59) % 20) + 61
            
            -- Get characters from different sections of our character set
            local char1 = charSet[index1]
            local char2 = charSet[index2]
            local char3 = charSet[index3]
            local char4 = charSet[index4]
            
            -- Add a position-based separator
            local separator = (i % 5 == 0) and "." or 
                             (i % 5 == 1) and "_" or
                             (i % 5 == 2) and "-" or
                             (i % 5 == 3) and "+" or ":"
            
            -- Add the encoded group
            result = result .. char1 .. char2 .. char3 .. char4 .. separator
        end
        
        -- Add a verification signature
        local verificationHash = secureHash(str .. tostring(key) .. tostring(timestamp))
        local verificationChars = {}
        local verStr = tostring(verificationHash)
        for i = 1, math.min(5, #verStr) do
            local digit = tonumber(string.sub(verStr, i, i))
            verificationChars[i] = charSet[digit + 1]
        end
        
        result = result .. "<<VERIFY>>"
        for i = 1, #verificationChars do
            result = result .. verificationChars[i]
        end
        result = result .. "<</VERIFY>>"
        
        return result
    end
    
    return customEncode(whitelistString, hash)
end

-- Create or update the local whitelist file
function WhitelistSystem:CreateLocalWhitelistFile()
    local originalWhitelist = self:GenerateWhitelistString()
    local obfuscatedWhitelist = self:ObfuscateWhitelistString(originalWhitelist)
    
    local success, result = pcall(function()
        if writefile then
            local content = [[
-- Whitelist System
-- This file contains your whitelist information
-- DO NOT MODIFY THIS FILE

local WhitelistData = {
    -- Original unobfuscated whitelist string
    Original = "]] .. originalWhitelist .. [[",
    
    -- Obfuscated whitelist string
    Obfuscated = "]] .. obfuscatedWhitelist .. [["
}

return WhitelistData
]]
            writefile(self.Config.LocalFile, content)
            return true
        else
            error("Cannot write local files")
        end
    end)
    
    if success then
        debugPrint("Successfully created local whitelist file")
        return {
            original = originalWhitelist,
            obfuscated = obfuscatedWhitelist
        }
    else
        debugPrint("Failed to create local whitelist file:", result)
        return {
            original = originalWhitelist,
            obfuscated = obfuscatedWhitelist
        }
    end
end

-- Load the local whitelist file
function WhitelistSystem:LoadLocalWhitelistFile()
    local success, result = pcall(function()
        if readfile and isfile and isfile(self.Config.LocalFile) then
            local content = readfile(self.Config.LocalFile)
            local func, err = loadstring(content)
            if func then
                local whitelistData = func()
                if type(whitelistData) == "table" and whitelistData.Original and whitelistData.Obfuscated then
                    return whitelistData
                else
                    error("Invalid whitelist data format")
                end
            else
                error("Failed to parse whitelist data: " .. tostring(err))
            end
        else
            error("Whitelist file does not exist")
        end
    end)
    
    if success then
        debugPrint("Successfully loaded local whitelist file")
        return {
            original = result.Original,
            obfuscated = result.Obfuscated
        }
    else
        debugPrint("Failed to load local whitelist file:", result)
        return nil
    end
end

-- Fetch whitelist data from GitHub
function WhitelistSystem:FetchWhitelistData()
    local success, result = pcall(function()
        local response = game:HttpGet(self.Config.GitHubRawURL)
        
        -- Basic validation to ensure it's a Lua table
        if response:match("return%s*{") then
            -- Use loadstring to convert the response to a Lua table
            local func, err = loadstring(response)
            if func then
                local whitelistData = func()
                if type(whitelistData) == "table" then
                    return whitelistData
                else
                    error("Whitelist data is not a table")
                end
            else
                error("Failed to parse whitelist data: " .. tostring(err))
            end
        else
            error("Invalid whitelist data format")
        end
    end)
    
    if success then
        debugPrint("Successfully fetched whitelist data from GitHub")
        return result
    else
        debugPrint("Failed to fetch whitelist data from GitHub:", result)
        return nil
    end
end

-- Check if the user is whitelisted
function WhitelistSystem:CheckWhitelist()
    -- First, try to load the local whitelist file
    local localWhitelist = self:LoadLocalWhitelistFile()
    
    -- If the local whitelist file doesn't exist or is invalid, create it
    if not localWhitelist then
        localWhitelist = self:CreateLocalWhitelistFile()
        
        -- Copy the obfuscated whitelist to clipboard
        pcall(function()
            if setclipboard then
                setclipboard(localWhitelist.obfuscated)
                print("Your obfuscated whitelist string has been copied to clipboard. Contact the developer to get whitelisted.")
            elseif writeclipboard then
                writeclipboard(localWhitelist.obfuscated)
                print("Your obfuscated whitelist string has been copied to clipboard. Contact the developer to get whitelisted.")
            else
                print("Your obfuscated whitelist string: " .. localWhitelist.obfuscated)
                print("Contact the developer with this string to get whitelisted.")
            end
        end)
    end
    
    -- Try to fetch whitelist data from GitHub
    local githubWhitelist = self:FetchWhitelistData()
    
    -- If we couldn't fetch the whitelist data, return false
    if not githubWhitelist then
        print("❌ Could not fetch whitelist data from GitHub")
        return false
    end
    
    -- Check if the user's whitelist string is in the whitelist
    for _, entry in ipairs(githubWhitelist) do
        if entry == localWhitelist.original or entry == localWhitelist.obfuscated then
            return true
        end
    end
    
    -- If not whitelisted, copy the obfuscated whitelist to clipboard again
    pcall(function()
        if setclipboard then
            setclipboard(localWhitelist.obfuscated)
            print("Your obfuscated whitelist string has been copied to clipboard. Contact the developer to get whitelisted.")
        elseif writeclipboard then
            writeclipboard(localWhitelist.obfuscated)
            print("Your obfuscated whitelist string has been copied to clipboard. Contact the developer to get whitelisted.")
        else
            print("Your obfuscated whitelist string: " .. localWhitelist.obfuscated)
            print("Contact the developer with this string to get whitelisted.")
        end
    end)
    
    return false
end

-- Initialize the whitelist system
function WhitelistSystem:Initialize()
    print("🔒 Initializing whitelist system...")
    
    -- Check if the user is whitelisted
    local isWhitelisted = self:CheckWhitelist()
    
    if isWhitelisted then
        print("✅ Access granted! You are whitelisted.")
        return true
    else
        print("❌ Access denied! You are not whitelisted.")
        
        -- Show a notification in-game
        pcall(function()
            local StarterGui = game:GetService("StarterGui")
            StarterGui:SetCore("SendNotification", {
                Title = "Whitelist Check Failed",
                Text = "You are not whitelisted. Contact the developer.",
                Duration = 10
            })
        end)
        
        return false
    end
end

-- Return the whitelist system
return WhitelistSystem
