-- Advanced Whitelist System with Custom Obfuscation
local WhitelistSystem = {
    GenerateWhitelistString = function(self)
        -- Safe function caller
        local function safecall(func, ...)
            if type(func) == "function" then
                local success, result = pcall(func, ...)
                if success then return result end
            end
            return nil
        end
        
        -- Get HWID with multiple fallbacks
        local hwid = nil
        hwid = safecall(function() return getexecutorhwid() end)
        if not hwid then hwid = safecall(function() return gethwid() end) end
        if not hwid then hwid = safecall(function() return get_hwid() end) end
        if not hwid then hwid = safecall(function() return getexecutoridentifier() end) end
        if not hwid then hwid = "UNKNOWN_HWID" end
        
        -- Get user data
        local userId = game:GetService("Players").LocalPlayer.UserId
        
        -- Get client ID
        local clientID = "UNKNOWN_CLIENT_ID"
        pcall(function()
            clientID = game:GetService("RbxAnalyticsService"):GetClientId()
        end)
        
        -- Create a persistent ID
        local function getPersistentID()
            local HttpService = game:GetService("HttpService")
            local filename = "lurnai_persistent_id.dat"
            
            local existingID = nil
            pcall(function()
                if readfile then existingID = readfile(filename) end
            end)
            
            if existingID and #existingID > 10 then
                return existingID
            end
            
            local newID = HttpService:GenerateGUID(false)
            pcall(function()
                if writefile then writefile(filename, newID) end
            end)
            
            return newID
        end
        
        local persistentID = getPersistentID()
        
        -- Get player name
        local playerName = game:GetService("Players").LocalPlayer.Name
        
        -- Get executor name
        local executorName = "Unknown"
        pcall(function()
            if identifyexecutor then executorName = identifyexecutor() end
            if executorName == "Unknown" and getexecutorname then executorName = getexecutorname() end
        end)
        
        -- Print all components for debugging
        print("HWID:", hwid)
        print("UserID:", userId)
        print("ClientID:", clientID)
        print("PersistentID:", persistentID)
        print("PlayerName:", playerName)
        print("ExecutorName:", executorName)
        
        -- Format the whitelist string with all identifiers
        local whitelistString = string.format("%s_%s_%s_%s_%s_%s", 
            hwid,
            tostring(userId),
            tostring(persistentID),
            tostring(clientID),
            playerName,
            executorName
        )
        
        -- Custom advanced hashing function
        local function customHash(str)
            local h1, h2, h3, h4 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476
            
            local function F(x, y, z) return (x & y) | (~x & z) end
            local function G(x, y, z) return (x & z) | (y & ~z) end
            local function H(x, y, z) return x ~ y ~ z end
            local function I(x, y, z) return y ~ (x | ~z) end
            
            local function rotateLeft(x, n)
                return ((x << n) | (x >> (32 - n))) & 0xFFFFFFFF
            end
            
            -- Process each character
            for i = 1, #str, 4 do
                local a, b, c, d = h1, h2, h3, h4
                
                -- Get up to 4 bytes
                local bytes = {0, 0, 0, 0}
                for j = 0, 3 do
                    if i + j <= #str then
                        bytes[j+1] = string.byte(str, i + j)
                    end
                end
                
                -- Mix operations
                a = (a + F(b, c, d) + bytes[1]) & 0xFFFFFFFF
                a = rotateLeft(a, 7)
                a = (a + b) & 0xFFFFFFFF
                
                d = (d + G(a, b, c) + bytes[2]) & 0xFFFFFFFF
                d = rotateLeft(d, 12)
                d = (d + a) & 0xFFFFFFFF
                
                c = (c + H(d, a, b) + bytes[3]) & 0xFFFFFFFF
                c = rotateLeft(c, 17)
                c = (c + d) & 0xFFFFFFFF
                
                b = (b + I(c, d, a) + bytes[4]) & 0xFFFFFFFF
                b = rotateLeft(b, 22)
                b = (b + c) & 0xFFFFFFFF
                
                h1, h2, h3, h4 = (h1 + a) & 0xFFFFFFFF, (h2 + b) & 0xFFFFFFFF, (h3 + c) & 0xFFFFFFFF, (h4 + d) & 0xFFFFFFFF
            end
            
            return string.format("%08x%08x%08x%08x", h1, h2, h3, h4)
        end
        
        -- Custom character sets for obfuscation
        local symbolSet1 = {"âš¡", "âœ¨", "â­", "ðŸ”¥", "ðŸ’«", "âš”ï¸", "ðŸ›¡ï¸", "ðŸ¹", "ðŸ—¡ï¸", "ðŸ”®"}
        local symbolSet2 = {"ðŸŒ‘", "ðŸŒ’", "ðŸŒ“", "ðŸŒ”", "ðŸŒ•", "ðŸŒ–", "ðŸŒ—", "ðŸŒ˜", "ðŸŒ™", "ðŸŒš"}
        local chineseSet = {"é¾", "é³³", "è™Ž", "éº’", "é·¹", "ç‹¼", "é¹¿", "ç†Š", "è›‡", "é¯¨"}
        local runicSet = {"áš ", "áš¢", "áš¦", "áš¨", "áš±", "áš²", "áš·", "áš¹", "ášº", "áš¾"}
        
        -- Advanced custom obfuscation
        local function customObfuscate(str)
            local hash = customHash(str)
            local timestamp = os.time()
            local seed = timestamp % 1000
            
            -- Create a unique key based on timestamp and hash
            local key = ""
            for i = 1, 8 do
                local hashPart = tonumber(string.sub(hash, (i-1)*4 + 1, i*4), 16) or 0
                key = key .. string.char((hashPart % 26) + 65)
            end
            
            -- Initialize result with a marker and timestamp
            local result = "âœ§âš" .. string.char(seed % 26 + 65) .. string.char((seed + 7) % 26 + 65)
            
            -- Add the hash in an obfuscated form
            for i = 1, #hash, 2 do
                local hashPart = string.sub(hash, i, i+1)
                local value = tonumber(hashPart, 16) or 0
                
                -- Select character set based on position
                local charSet = (i % 8 == 0) and symbolSet1 or
                               (i % 8 == 2) and symbolSet2 or
                               (i % 8 == 4) and chineseSet or runicSet
                
                -- Map value to character
                local index = (value % #charSet) + 1
                result = result .. charSet[index]
            end
            
            -- Add separator
            result = result .. "âšœï¸"
            
            -- Encode the actual string with multiple layers
            for i = 1, #str do
                local char = string.sub(str, i, i)
                local byte = string.byte(char)
                
                -- Apply key-based transformation
                local keyChar = string.sub(key, (i % #key) + 1, (i % #key) + 1)
                local keyByte = string.byte(keyChar)
                
                -- Complex transformation
                local transformed = (byte * 3 + keyByte * 5 + seed + i) % 1000
                
                -- Split into three parts for more obfuscation
                local part1 = transformed % 10
                local part2 = math.floor(transformed / 10) % 10
                local part3 = math.floor(transformed / 100)
                
                -- Map each part to a different character set
                local symbol1 = symbolSet1[(part1 + 1)]
                local symbol2 = chineseSet[(part2 + 1)]
                local symbol3 = runicSet[(part3 + 1)]
                
                -- Add to result with position-based separator
                local separator = (i % 4 == 0) and "âœ¦" or 
                                 (i % 4 == 1) and "âœ§" or
                                 (i % 4 == 2) and "âœª" or "âœ«"
                
                result = result .. symbol1 .. symbol2 .. symbol3 .. separator
            end
            
            -- Add verification code
            local verificationCode = customHash(str .. key .. tostring(timestamp))
            result = result .. "âšâœ§" .. string.sub(verificationCode, 1, 8)
            
            return result
        end
        
        local obfuscatedString = customObfuscate(whitelistString)
        print("Generated whitelist string:", obfuscatedString)
        return obfuscatedString
    end,
    
    VerifyAccess = function(self, whitelistData)
        -- Generate the user's whitelist string
        local userWhitelistString = self:GenerateWhitelistString()
        
        -- Check if the user's whitelist string is in the whitelist
        for _, whitelistedString in ipairs(whitelistData) do
            if whitelistedString == userWhitelistString then
                print("âœ… è®¿é—®å·²æŽˆæƒï¼æ‚¨å·²é€šè¿‡éªŒè¯ã€‚")
                return true
            end
        end
        
        print("âŒ è®¿é—®è¢«æ‹’ç»ï¼æ‚¨æœªèŽ·å¾—æŽˆæƒã€‚")
        -- Copy the user's whitelist string to clipboard for easy whitelisting
        pcall(function()
            if setclipboard then
                setclipboard(userWhitelistString)
                print("æ‚¨çš„æŽˆæƒç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚è¯·è”ç³»å¼€å‘è€…èŽ·å–æŽˆæƒã€‚")
            elseif writeclipboard then
                writeclipboard(userWhitelistString)
                print("æ‚¨çš„æŽˆæƒç å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ã€‚è¯·è”ç³»å¼€å‘è€…èŽ·å–æŽˆæƒã€‚")
            else
                print("æ‚¨çš„æŽˆæƒç : " .. userWhitelistString)
                print("è¯·ä½¿ç”¨æ­¤ä»£ç è”ç³»å¼€å‘è€…èŽ·å–æŽˆæƒã€‚")
            end
        end)
        
        return false
    end,
    
    -- Admin tools for whitelist management
    AdminTools = {
        -- This function would be used by admins to decode a whitelist string
        -- It's intentionally complex and incomplete to prevent reverse engineering
        DecodePartial = function(obfuscatedString)
            if not string.match(obfuscatedString, "^âœ§âš") then
                return "Invalid format"
            end
            
            -- Extract the seed characters
            local seedChar1 = string.sub(obfuscatedString, 3, 3)
            local seedChar2 = string.sub(obfuscatedString, 4, 4)
            
            -- Calculate approximate seed
            local seed = (string.byte(seedChar1) - 65) % 26
            
            -- Find the verification marker
            local verificationPos = string.find(obfuscatedString, "âšâœ§")
            if not verificationPos then
                return "Corrupted string"
            end
            
            -- Extract verification code
            local verificationCode = string.sub(obfuscatedString, verificationPos + 2)
            
            return {
                seed = seed,
                verificationCode = verificationCode,
                isValid = #verificationCode == 8
            }
        end
    }
}

-- Empty whitelist data for testing
local whitelistData = {}

-- Generate a whitelist string for the current user
local userString = WhitelistSystem:GenerateWhitelistString()
print("å°†æ­¤æŽˆæƒç æ·»åŠ åˆ°æ‚¨çš„whitelist_data.luaæ–‡ä»¶ä¸­:")
print(userString)

-- Verify access (will fail since whitelist is empty)
local hasAccess = WhitelistSystem:VerifyAccess(whitelistData)
if hasAccess then
    print("âœ… éªŒè¯æˆåŠŸï¼æ‚¨çŽ°åœ¨å¯ä»¥åŠ è½½ä¸»è„šæœ¬ã€‚")
else
    print("âŒ éªŒè¯å¤±è´¥ã€‚è¯·å°†æ‚¨çš„æŽˆæƒç æ·»åŠ åˆ°ç™½åå•ä¸­ã€‚")
end
