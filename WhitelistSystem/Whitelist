-- Webhook System
local WebhookSystem = {}

-- Configuration
WebhookSystem.Config = {
    WebhookURL = "https://discord.com/api/webhooks/1368393336183849085/hd-r2quKsj1_nw5YK1JEBHlpktkTVlGJH_hIB4W5aBJyL_Ik3WdtW16mZ_kU-avGYKkI",
    PingUserID = "1342535168002359419",
    Debug = true
}

-- Always print function (regardless of debug setting)
local function alwaysPrint(...)
    local args = {...}
    local message = "[Webhook] "
    for i, arg in ipairs(args) do
        message = message .. tostring(arg) .. " "
    end
    print(message)
end

-- Function to send a simple webhook message
function WebhookSystem:SendSimpleMessage(message)
    alwaysPrint("Attempting to send message: " .. message)
    
    local webhookData = {
        content = message
    }
    
    local jsonData = game:GetService("HttpService"):JSONEncode(webhookData)
    alwaysPrint("JSON data: " .. jsonData)
    
    local success = false
    local errorMessage = ""
    
    -- Method 1: http_request
    if http_request then
        alwaysPrint("Trying http_request method...")
        local status, response = pcall(function()
            return http_request({
                Url = self.Config.WebhookURL,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonData
            })
        end)
        
        if status then
            alwaysPrint("http_request succeeded, response status: " .. tostring(response.StatusCode))
            alwaysPrint("Response body: " .. tostring(response.Body))
            if response.StatusCode == 200 or response.StatusCode == 204 then
                success = true
            else
                errorMessage = "HTTP status code: " .. tostring(response.StatusCode)
            end
        else
            alwaysPrint("http_request failed with error: " .. tostring(response))
            errorMessage = "http_request error: " .. tostring(response)
        end
    else
        alwaysPrint("http_request is not available")
    end
    
    -- Method 2: syn.request
    if not success and syn and syn.request then
        alwaysPrint("Trying syn.request method...")
        local status, response = pcall(function()
            return syn.request({
                Url = self.Config.WebhookURL,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonData
            })
        end)
        
        if status then
            alwaysPrint("syn.request succeeded, response status: " .. tostring(response.StatusCode))
            alwaysPrint("Response body: " .. tostring(response.Body))
            if response.StatusCode == 200 or response.StatusCode == 204 then
                success = true
            else
                errorMessage = "HTTP status code: " .. tostring(response.StatusCode)
            end
        else
            alwaysPrint("syn.request failed with error: " .. tostring(response))
            errorMessage = "syn.request error: " .. tostring(response)
        end
    else
        alwaysPrint("syn.request is not available")
    end
    
    -- Method 3: request
    if not success and request then
        alwaysPrint("Trying request method...")
        local status, response = pcall(function()
            return request({
                Url = self.Config.WebhookURL,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonData
            })
        end)
        
        if status then
            alwaysPrint("request succeeded, response status: " .. tostring(response.StatusCode))
            alwaysPrint("Response body: " .. tostring(response.Body))
            if response.StatusCode == 200 or response.StatusCode == 204 then
                success = true
            else
                errorMessage = "HTTP status code: " .. tostring(response.StatusCode)
            end
        else
            alwaysPrint("request failed with error: " .. tostring(response))
            errorMessage = "request error: " .. tostring(response)
        end
    else
        alwaysPrint("request is not available")
    end
    
    -- Method 4: HttpService (fallback)
    if not success then
        alwaysPrint("Trying HttpService method...")
        local HttpService = game:GetService("HttpService")
        local status, response = pcall(function()
            return HttpService:RequestAsync({
                Url = self.Config.WebhookURL,
                Method = "POST",
                Headers = {
                    ["Content-Type"] = "application/json"
                },
                Body = jsonData
            })
        end)
        
        if status then
            alwaysPrint("HttpService succeeded, response status: " .. tostring(response.StatusCode))
            alwaysPrint("Response body: " .. tostring(response.Body))
            if response.StatusCode == 200 or response.StatusCode == 204 then
                success = true
            else
                errorMessage = "HTTP status code: " .. tostring(response.StatusCode)
            end
        else
            alwaysPrint("HttpService failed with error: " .. tostring(response))
            errorMessage = "HttpService error: " .. tostring(response)
        end
    else
        alwaysPrint("HttpService RequestAsync may not be available in this context")
    end
    
    if success then
        alwaysPrint("Successfully sent message!")
    else
        alwaysPrint("Failed to send message. Error: " .. errorMessage)
    end
    
    return success
end

-- Send data to webhook step by step
function WebhookSystem:SendToWebhook(isWhitelisted, whitelistString, executorName)
    alwaysPrint("Starting webhook process...")
    alwaysPrint("Webhook URL: " .. self.Config.WebhookURL)
    
    -- Check if any HTTP request methods are available
    local hasHttpRequest = http_request ~= nil
    local hasSynRequest = syn ~= nil and syn.request ~= nil
    local hasRequest = request ~= nil
    local canUseHttpService = pcall(function() return game:GetService("HttpService"):JSONEncode({test = true}) end)
    
    alwaysPrint("Available HTTP methods:")
    alwaysPrint("- http_request: " .. tostring(hasHttpRequest))
    alwaysPrint("- syn.request: " .. tostring(hasSynRequest))
    alwaysPrint("- request: " .. tostring(hasRequest))
    alwaysPrint("- HttpService: " .. tostring(canUseHttpService))
    
    if not (hasHttpRequest or hasSynRequest or hasRequest) then
        alwaysPrint("WARNING: No standard HTTP request methods available. This may be due to your executor limitations.")
    end
    
    -- Get player information
    local player = game:GetService("Players").LocalPlayer
    local userId = player.UserId
    local username = player.Name
    local displayName = player.DisplayName
    
    alwaysPrint("Player info:")
    alwaysPrint("- Username: " .. username)
    alwaysPrint("- Display Name: " .. displayName)
    alwaysPrint("- User ID: " .. userId)
    
    -- Get game information
    local gameName = "Unknown Game"
    local placeId = game.PlaceId
    
    pcall(function()
        gameName = game:GetService("MarketplaceService"):GetProductInfo(placeId).Name
    end)
    
    alwaysPrint("Game info:")
    alwaysPrint("- Game Name: " .. gameName)
    alwaysPrint("- Place ID: " .. placeId)
    
    -- Step 1: Send a test message
    alwaysPrint("\n--- STEP 1: Sending test message ---")
    local testResult = self:SendSimpleMessage("Whitelist System Test Message")
    alwaysPrint("Test message result: " .. tostring(testResult))
    
    -- Step 2: Send username
    alwaysPrint("\n--- STEP 2: Sending username ---")
    local usernameResult = self:SendSimpleMessage("Username: " .. username)
    alwaysPrint("Username message result: " .. tostring(usernameResult))
    
    -- Step 3: Send display name
    alwaysPrint("\n--- STEP 3: Sending display name ---")
    local displayResult = self:SendSimpleMessage("Display Name: " .. displayName)
    alwaysPrint("Display name message result: " .. tostring(displayResult))
    
    -- Step 4: Send user ID
    alwaysPrint("\n--- STEP 4: Sending user ID ---")
    local userIdResult = self:SendSimpleMessage("User ID: " .. userId)
    alwaysPrint("User ID message result: " .. tostring(userIdResult))
    
    -- Step 5: Send game info
    alwaysPrint("\n--- STEP 5: Sending game info ---")
    local gameResult = self:SendSimpleMessage("Game: " .. gameName .. " (Place ID: " .. placeId .. ")")
    alwaysPrint("Game info message result: " .. tostring(gameResult))
    
    -- Step 6: Send executor name
    alwaysPrint("\n--- STEP 6: Sending executor name ---")
    local executorResult = self:SendSimpleMessage("Executor: " .. (executorName or "Unknown"))
    alwaysPrint("Executor message result: " .. tostring(executorResult))
    
    -- Step 7: Send whitelist status
    alwaysPrint("\n--- STEP 7: Sending whitelist status ---")
    local whitelistResult = self:SendSimpleMessage("Whitelisted: " .. (isWhitelisted and "Yes" or "No"))
    alwaysPrint("Whitelist status message result: " .. tostring(whitelistResult))
    
    alwaysPrint("\nWebhook process completed!")
    return true
end

-- Main function to run both systems
local function RunWhitelistWithWebhook()
    print("Starting whitelist check with webhook notification...")
    
    -- Initialize whitelist system
    local isWhitelisted, whitelistString, executorName = WhitelistSystem:Initialize()
    
    -- Send webhook notification with detailed logging
    WebhookSystem:SendToWebhook(isWhitelisted, whitelistString, executorName)
    
    -- Return whitelist result
    return isWhitelisted
end

-- Run the combined system
local isWhitelisted = RunWhitelistWithWebhook()

-- Continue with your script if whitelisted
if isWhitelisted then
    print("Access granted! User is whitelisted.")
    -- Your script code here
else
    print("Access denied! User is not whitelisted.")
end

return isWhitelisted
